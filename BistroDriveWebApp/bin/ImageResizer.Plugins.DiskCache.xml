<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ImageResizer.Plugins.DiskCache</name>
    </assembly>
    <members>
        <member name="P:ImageResizer.Plugins.DiskCache.Async.AsyncWriteCollection.MaxQueueBytes">
            <summary>
            How many bytes of buffered file data to hold in memory before refusing futher queue requests and forcing them to be executed synchronously.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWriteCollection.Get(System.String)">
            <summary>
            If the collection contains the specified item, it is returned. Otherwise, null is returned.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWriteCollection.GetQueuedBufferBytes">
            <summary>
            Returns how many bytes are allocated by buffers in the queue. May be 2x the amount of data. Represents how much ram is being used by the queue, not the amount of encoded bytes that will actually be written.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWriteCollection.Remove(ImageResizer.Plugins.DiskCache.Async.AsyncWrite)">
            <summary>
            Removes the specified object based on its relativepath and modifieddateutc values.
            </summary>
            <param name="w"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWriteCollection.Queue(ImageResizer.Plugins.DiskCache.Async.AsyncWrite,ImageResizer.Plugins.DiskCache.Async.AsyncWriteCollection.WriterDelegate)">
            <summary>
            Returns false when (a) the specified AsyncWrite value already exists, (b) the queue is full, or (c) the thread pool queue is full
            </summary>
            <param name="w"></param>
            <param name="writerDelegate"></param>
            <returns></returns>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.Async.AsyncWrite.JobCreatedAt">
            <summary>
            Returns the UTC time this AsyncWrite object was created.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWrite.GetDataLength">
            <summary>
            Returns the length of the Data
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWrite.GetBufferLength">
            <summary>
            Returns the length of the buffer capacity
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Async.AsyncWrite.GetReadonlyStream">
            <summary>
            Wraps the data in a readonly MemoryStream so it can be accessed on another thread
            </summary>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache">
            <summary>
            Handles access to a disk-based file cache. Handles locking and versioning. 
            Supports subfolders for scalability.
            </summary>
        </member>
        <member name="E:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.CacheResultReturned">
            <summary>
            Fired immediately before GetCachedFile return the result value. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.Locks">
            <summary>
            Provides string-based locking for file write access.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.QueueLocks">
            <summary>
            Provides string-based locking for image resizing (not writing, just processing). Prevents duplication of efforts in asynchronous mode, where 'Locks' is not being used.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.CurrentWrites">
            <summary>
            Contains all the queued and in-progress writes to the cache. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.Index">
            <summary>
            Provides an in-memory index of the cache.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.GetCachedFile(System.String,System.String,ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.AsyncWriteResult,System.Int32)">
            <summary>
            If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries to cache the data and return the path.
            </summary>
            <param name="keyBasis">The basis for the cache key.</param>
            <param name="extension">The extension to use for the cached file.</param>
            <param name="writeCallback">A method that accepts a Stream argument and writes the data to it.</param>
            =<param name="timeoutMs"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.GetCachedFile(System.String,System.String,ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.AsyncWriteResult,System.Int32,System.Boolean)">
            <summary>
            May return either a physical file name or a MemoryStream with the data. 
            Faster than GetCachedFile, as writes are (usually) asynchronous. If the write queue is full, the write is forced to be synchronous again.
            Identical to GetCachedFile() when asynchronous=false
            </summary>
            <param name="keyBasis"></param>
            <param name="extension"></param>
            <param name="writeCallback"></param>
            <param name="timeoutMs"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.TryWriteFile(ImageResizer.Plugins.DiskCache.CacheResult,System.String,System.String,ImageResizer.Plugins.DiskCache.AsyncCustomDiskCache.AsyncWriteResult,System.Int32,System.Boolean)">
            <summary>
            Returns true if either (a) the file was written, or (b) the file already existed with a matching modified date.
            Returns false if the in-process lock failed. Throws an exception if any kind of file or processing exception occurs.
            </summary>
            <param name="result"></param>
            <param name="physicalPath"></param>
            <param name="relativePath"></param>
            <param name="writeCallback"></param>
            <param name="timeoutMs"></param>
            <param name="recheckFS"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.LockProvider">
            <summary>
            Provides locking based on a string key. 
            Locks are local to the LockProvider instance.
            The class handles disposing of unused locks. Generally used for 
            coordinating writes to files (of which there can be millions). 
            Only keeps key/lock pairs in memory which are in use.
            Thread-safe.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.LockProvider.locks">
            <summary>
            The only objects in this collection should be for open files. 
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.LockProvider.createLock">
            <summary>
            Synchronization object for modifications to the 'locks' dictionary
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.LockProvider.MayBeLocked(System.String)">
            <summary>
            Returns true if the given key *might* be locked.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.LockProvider.TryExecute(System.String,System.Int32,ImageResizer.Plugins.DiskCache.LockCallback)">
            <summary>
            Attempts to execute the 'success' callback inside a lock based on 'key'.  If successful, returns true.
            If the lock cannot be acquired within 'timoutMs', returns false
            In a worst-case scenario, it could take up to twice as long as 'timeoutMs' to return false.
            </summary>
            <param name="key"></param>
            <param name="timeoutMs"></param>
            <param name="success"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFileInfo.#ctor(System.IO.FileInfo,ImageResizer.Plugins.DiskCache.CachedFileInfo)">
            <summary>
            Uses old.AccessedUtc if it is newer than FileInfo.LastAccessTimeUtc
            </summary>
            <param name="f"></param>
            <param name="old"></param>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CachedFileInfo.ModifiedUtc">
            <summary>
            The modified date of the source file that the cached file is based on.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CachedFileInfo.AccessedUtc">
            <summary>
            The last time the file was accessed. Will not match NTFS date, this value is updated by DiskCache.
            When first loaded from NTFS, it will be granular to about an hour, due to NTFS delayed write. Also, windows Vista and higher never write accessed dates. 
            We update this value in memory, and flush it to disk lazily. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CachedFileInfo.UpdatedUtc">
            <summary>
            The Created date of the cached file - the last time the cached file was written to
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.CachedFolder">
            <summary>
            Represents a cached view of a folder of cached items
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CachedFolder.IsValid">
            <summary>
            Defaults to false. Set to true immediately after being refreshed from the filesystem.
            Set to false if a file disappears from the filesystem cache without the cache index being notified first.
            Used by the cleanup system - not of importance to the cache write system.
            </summary>
        </member>
        <member name="E:ImageResizer.Plugins.DiskCache.CachedFolder.FileDisappeared">
            <summary>
            Fired when a file disappears from the cache folder without the cache index knowing about it.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getCachedFileInfo(System.String)">
            <summary>
            Returns null if (a) the file doesn't exist, or (b) the file isn't populated. Calling code should always fall back to filesystem calls on a null result.
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.setCachedFileInfo(System.String,ImageResizer.Plugins.DiskCache.CachedFileInfo)">
            <summary>
            Sets the CachedFileInfo object for the specified path, creating any needed folders along the way.
            If 'null', the item will be removed, and no missing folder will be created.
            </summary>
            <param name="relativePath"></param>
            <param name="info"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.bumpDateIfExists(System.String)">
            <summary>
            Tries to set the AccessedUtc of the specified file to the current date (just in memory, not on the filesystem).
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getFileInfo(System.String,System.String)">
            <summary>
            Gets a CachedFileInfo object for the file even if it isn't in the cache (falls back to the filesystem)
            </summary>
            <param name="relativePath"></param>
            <param name="physicalPath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getFileInfoCertainExists(System.String,System.String)">
            <summary>
            Verifies the file exists before returning the cached data. 
            Discrepancies in file existence result in OnFileDisappeard being fired.
            </summary>
            <param name="relativePath"></param>
            <param name="physicalPath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.GetIsValid(System.String)">
            <summary>
            Returns the value of IsValid on the specified folder if present, or 'false' if not present.
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getFolder(System.String)">
            <summary>
            Not thread safe.
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getSubfolders(System.String)">
            <summary>
            returns a list 
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getSubfilesCopy(System.String)">
            <summary>
            returns a dictionary of files. 
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.getSortedSubfiles(System.String)">
            <summary>
            returns a dictionary of files. 
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.populate(System.String,System.String)">
            <summary>
            Refreshes file and folder listing for this folder (non-recursive). Sets IsValid=true afterwards.
            
            </summary>
            <param name="relativePath"></param>
            <param name="physicalPath"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.populateSubfolders(System.String,System.String)">
            <summary>
            Updates  the 'folders' dictionary to match the folders that exist on disk. ONLY UPDATES THE LOCAL FOLDER
            </summary>
            <param name="relativePath"></param>
            <param name="physicalPath"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.populateFiles(System.String,System.String)">
            <summary>
            Updates the 'files' dictionary to match the files that exist on disk. Uses the accessedUtc values from the previous dictionary if they are newer.
            </summary>
            <param name="relativePath"></param>
            <param name="physicalPath"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.roughCompare(System.DateTime,System.DateTime)">
            <summary>
            Returns true if both dates are equal to the nearest 200th of a second.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CachedFolder.checkRelativePath(System.String)">
            <summary>
            
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.CacheIndex">
            <summary>
            Provides thread-safe access to the index of the disk cache
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CacheQueryResult.Failed">
            <summary>
            Failed to acquire a lock on the cached item within the timeout period
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CacheQueryResult.Miss">
            <summary>
            The item wasn't cached, but was successfully added to the cache (or queued, in which case you should read .Data instead of .PhysicalPath)
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CacheQueryResult.Hit">
            <summary>
            The item was already in the cache.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CacheResult.PhysicalPath">
            <summary>
            The physical path to the cached item. Verify .Data is null before trying to read from this file.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CacheResult.Data">
            <summary>
            Provides a read-only stream to the data. Usually a MemoryStream instance, but you should dispose it once you are done. 
            If this value is not null, it indicates that the file has not yet been written to disk, and you should read it from this stream instead.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CacheResult.RelativePath">
            <summary>
            The path relative to the cache
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CacheResult.Result">
            <summary>
            The result of the cache check
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupManager.ExteralProcessCleaning">
            <summary>
            When true, indicates that another process is managing cleanup operations - this thread is idle, waiting for the other process to end before it can pick up work.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupManager.BeLazy">
            <summary>
            Notifies the CleanupManager that a request is in process. Helps CleanupManager optimize background work so it doesn't interfere with request processing.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupManager.AddedFile(System.String)">
            <summary>
            Notifies the CleanupManager that a file was added under the specified relative path. Allows CleanupManager to detect when a folder needs cleanup work.
            </summary>
            <param name="relativePath"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Cleanup.CleanupQueue.QueueIfUnique(ImageResizer.Plugins.DiskCache.CleanupWorkItem)">
            <summary>
            Queues the item if no other identical items exist in the queue. Returns true if the item was added.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Cleanup.CleanupQueue.InsertRange(System.Collections.Generic.IList{ImageResizer.Plugins.DiskCache.CleanupWorkItem})">
            <summary>
            Inserts the specified list of items and the end of the queue. They will be next items popped.
            They will pop off the list in the same order they exist in 'items' (i.e, they are inserted in reverse order).
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.Cleanup.CleanupQueue.ReplaceWith(ImageResizer.Plugins.DiskCache.CleanupWorkItem)">
            <summary>
            Performs an atomic clear and enqueue of the specified item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupWorker.#ctor(ImageResizer.Configuration.Logging.ILoggerProvider,ImageResizer.Plugins.DiskCache.CleanupStrategy,ImageResizer.Plugins.DiskCache.Cleanup.CleanupQueue,ImageResizer.Plugins.DiskCache.ICleanableCache)">
            <summary>
            Creates and starts a thread that consumes the queue, pausing until notified when 'queue' empties.
            </summary>
            <param name="lp"></param>
            <param name="cs"></param>
            <param name="queue"></param>
            <param name="cache"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupWorker.MayHaveWork">
            <summary>
            Tells the worker to check the queue for more work.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorker.lastFoundItemsOverMax">
            <summary>
            The last time a cache folder exceeded both the optimum and maximum limits for file count. 
            If recent, indicates a misconfiguration; the subfolders="" count needs to be increased.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorker.lastBusy">
            <summary>
            The last time a cache query came through
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupWorker.BeLazy">
            <summary>
            Tells the worker to avoid work for a little bit.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorker.lastWorked">
            <summary>
            The last time we did work (or attempted to do work, failing if the queue was empty)
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupWorker.ExteralProcessCleaning">
            <summary>
            When true, indicates that another process is managing cleanup operations - this thread is idle, waiting for the other process to end before it can pick up work.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorker.otherProcessManagingCleanup">
            <summary>
            When true, indicates that another process is managing cleanup operations - this thread is idle, waiting for the other process to end before it can pick up work.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupWorker.main">
            <summary>
            Thread runs this method.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupWorker.mainInner">
            <summary>
            Processes work items from the queue, using at most 50%
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupWorker.DoWorkFor(System.TimeSpan)">
            <summary>
            Processes items from the queue for roughly the specified amount of time.
            Returns false if the queue was empty.
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.CleanupWorkItem">
            <summary>
            An item in the work queue
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupWorkItem.LazyProvider">
            <summary>
            Should be a delegate a CleanupWorkItem instance (which doesn't have LazyProvider value, but has RelativePath and PhyscialPath values). May return null
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupWorkItem.RelativePath">
            <summary>
            Cache-relative path 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupWorkItem.PhysicalPath">
            <summary>
            Physcial path
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorkItem.Kind.PopulateFolderRecursive">
            <summary>
            If the .IsValid is false, populates the folder, enqueing more PopulateFolderRecursive items for all subfolders discovered. Sets IsValid to true  
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorkItem.Kind.CleanFolderRecursive">
            <summary>
            Requires a valid folder.  
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorkItem.Kind.CleanFolder">
            <summary>
            Cleans the folder, enqueing RemoveFile tasks for everything that needs to be removed.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorkItem.Kind.PopulateFolder">
            <summary>
            Populates (non-recursive) the files and folders inside the specified directory.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorkItem.Kind.RemoveFile">
            <summary>
            Removes a single file, with the file and dir being determined at executing time via the LazyProvider delegate.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.CleanupWorkItem.Kind.FlushAccessedDate">
            <summary>
            Calls File.SetLastAccessedTimeUtc() using the in-memory value, if present.
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.CustomDiskCache">
            <summary>
            Handles access to a disk-based file cache. Handles locking and versioning. 
            Supports subfolders for scalability.
            </summary>
        </member>
        <member name="E:ImageResizer.Plugins.DiskCache.CustomDiskCache.CacheResultReturned">
            <summary>
            Fired immediately before GetCachedFile return the result value. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CustomDiskCache.Locks">
            <summary>
            Provides string-based locking for file write access.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CustomDiskCache.QueueLocks">
            <summary>
            Provides string-based locking for image resizing (not writing, just processing). Prevents duplication of efforts in asynchronous mode, where 'Locks' is not being used.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CustomDiskCache.CurrentWrites">
            <summary>
            Contains all the queued and in-progress writes to the cache. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CustomDiskCache.Index">
            <summary>
            Provides an in-memory index of the cache.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CustomDiskCache.GetCachedFile(System.String,System.String,ImageResizer.Caching.ResizeImageDelegate,System.Int32)">
            <summary>
            If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries to cache the data and return the path.
            </summary>
            <param name="keyBasis">The basis for the cache key.</param>
            <param name="extension">The extension to use for the cached file.</param>
            <param name="writeCallback">A method that accepts a Stream argument and writes the data to it.</param>
            =<param name="timeoutMs"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CustomDiskCache.GetCachedFile(System.String,System.String,ImageResizer.Caching.ResizeImageDelegate,System.Int32,System.Boolean)">
            <summary>
            May return either a physical file name or a MemoryStream with the data. 
            Faster than GetCachedFile, as writes are (usually) asynchronous. If the write queue is full, the write is forced to be synchronous again.
            Identical to GetCachedFile() when asynchronous=false
            </summary>
            <param name="keyBasis"></param>
            <param name="extension"></param>
            <param name="writeCallback"></param>
            <param name="timeoutMs"></param>
            <param name="asynchronous"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CustomDiskCache.TryWriteFile(ImageResizer.Plugins.DiskCache.CacheResult,System.String,System.String,ImageResizer.Caching.ResizeImageDelegate,System.Int32,System.Boolean)">
            <summary>
            Returns true if either (a) the file was written, or (b) the file already existed with a matching modified date.
            Returns false if the in-process lock failed. Throws an exception if any kind of file or processing exception occurs.
            </summary>
            <param name="result"></param>
            <param name="physicalPath"></param>
            <param name="relativePath"></param>
            <param name="writeCallback"></param>
            <param name="timeoutMs"></param>
            <param name="recheckFS"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.DiskCacheException">
            <summary>
            Indicates a problem with disk caching. Causes include a missing (or too small) ImageDiskCacheDir setting, and severe I/O locking preventing 
            the cache dir from being cleaned at all.
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.DiskCache">
            <summary>
            Provides methods for creating, maintaining, and securing the disk cache. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.Subfolders">
            <summary>
            Controls how many subfolders to use for disk caching. Rounded to the next power of to. (1->2, 3->4, 5->8, 9->16, 17->32, 33->64, 65->128,129->256,etc.)
            NTFS does not handle more than 8,000 files per folder well. Larger folders also make cleanup more resource-intensive.
            Defaults to 8192, which combined with the default setting of 400 images per folder, allows for scalability to ~1.5 million actively used image versions. 
            For example, given a desired cache size of 100,000 items, this should be set to 256.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.Enabled">
            <summary>
            Allows disk caching to be disabled for debugging purposes. Defaults to true.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.AutoClean">
            <summary>
            If true, items from the cache folder will be automatically 'garbage collected' if the cache size limits are exceeded.
            Defaults to false.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.CleanupStrategy">
            <summary>
            Only relevant when AutoClean=true. Settings about how background cache cleanup are performed.
            It is best not to modify these settings. There are very complicated and non-obvious factors involved in their choice.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.DiskCache.cacheAccessTimeout">
            <summary>
            Sets the timeout time to 15 seconds as default.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.CacheAccessTimeout">
            <summary>
            How many milliseconds to wait for a cached item to be available. Values below 0 are set to 0. Defaults to 15 seconds.
            Actual time spent waiting may be 2 or 3x this value, if multiple layers of synchronization require a wait.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.AsyncWrites">
            <summary>
            If true, writes to the disk cache will be performed outside the request thread, allowing responses to return to the client quicker. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.AsyncBufferSize">
            <summary>
            If more than this amount of memory (in bytes) is currently allocated by queued writes, the request will be processed synchronously instead of asynchronously.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.VirtualCacheDir">
            <summary>
            Sets the location of the cache directory. 
            Can be a virtual path (like /App/imagecache) or an application-relative path (like ~/imagecache, the default).
            Relative paths are assummed to be relative to the application root.
            All values are converted to virtual path format upon assignment (/App/imagecache)
            Will throw an InvalidOperationException if changed after the plugin is installed.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.PhysicalCacheDir">
            <summary>
            Returns the physical path of the cache directory specified in VirtualCacheDir.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.BeforeSettingChanged">
            <summary>
            Throws an exception if the class is already modified
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.#ctor">
            <summary>
            Creates a disk cache in the /imagecache folder
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.#ctor(System.String)">
            <summary>
            Creates a DiskCache instance at the specified location. Must be installed as a plugin to be operational.
            </summary>
            <param name="virtualDir"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.LoadSettings(ImageResizer.Configuration.Config)">
            <summary>
            Uses the defaults from the resizing.diskcache section in the specified configuration.
            Throws an invalid operation exception if the DiskCache is already started.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.Install(ImageResizer.Configuration.Config)">
            <summary>
            Loads the settings from 'c', starts the cache, and registers the plugin.
            Will throw an invalidoperationexception if already started.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.Uninstall(ImageResizer.Configuration.Config)">
            <summary>
            Removes the plugin from the given configuration container
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.IsConfigurationValid">
            <summary>
            Returns true if the configured settings are valid and .NET (not NTFS) permissions will work.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.HasFileIOPermission">
            <summary>
            Returns true if .NET permissions allow writing to the cache directory. Does not check NTFS permissions. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.Started">
            <summary>
            Returns true if the DiskCache instance is operational.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.Start">
            <summary>
            Attempts to start the DiskCache using the current settings. Returns true if succesful or if already started. Returns false on a configuration error.
            Called by Install()
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.DiskCache.Stop">
            <summary>
            Returns true if stopped succesfully. Cannot be restarted
            </summary>
            <returns></returns>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.DiskCache.LicenseFeatureCodes">
            <summary>
            Returns the license key feature codes that are able to activate this plugins.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupStrategy.LoadFrom(ImageResizer.Configuration.Xml.Node)">
            <summary>
            Loads settings from the specified node. Attribute names and property names must match.
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupStrategy.SaveDefaults">
            <summary>
            Saves the current settings to the dictionary of default settings.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.CleanupStrategy.RestoreDefaults">
            <summary>
            Restores the default property valies
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.StartupDelay">
            <summary>
            How long to wait before beginning the initial cache indexing and cleanup.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.MinDelay">
            <summary>
            The minimum amount of time to wait after the most recent BeLazy to begin working again.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.MaxDelay">
            <summary>
            The maximum amount of time to wait between work segements
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.OptimalWorkSegmentLength">
            <summary>
            The optimal length for a work segment. Not always achieved.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.TargetItemsPerFolder">
            <summary>
            The ideal number of cached files per folder. (defaults to 400) Only reached if it can be achieved without volating the AvoidRemoval... limits
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.MaximumItemsPerFolder">
            <summary>
            The maximum number of cached files per folder. (defaults to 1000) Only reached if it can be achieved without violating the ProhibitRemoval... limits
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.AvoidRemovalIfUsedWithin">
            <summary>
            Please note "LastUsed" values are (initially) only accurate to about a hour, due to delayed write. 
            If a file has been used after the app started running, the last used date is accurate.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.DiskCache.CleanupStrategy.ProhibitRemovalIfUsedWithin">
            <summary>
            Please note "LastUsed" values are (initially) only accurate to about a hour, due to delayed write. 
            If a file has been used after the app started running, the last used date is accurate.
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.AsyncLockProvider">
            <summary>
            Provides locking based on a string key. 
            Locks are local to the LockProvider instance.
            The class handles disposing of unused locks. Generally used for 
            coordinating writes to files (of which there can be millions). 
            Only keeps key/lock pairs in memory which are in use.
            Thread-safe.
            Uses SemaphoreSlim instead of locks to be thread-context agnostic.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.AsyncLockProvider.locks">
            <summary>
            The only objects in this collection should be for open files. 
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.AsyncLockProvider.createLock">
            <summary>
            Synchronization object for modifications to the 'locks' dictionary
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.AsyncLockProvider.MayBeLocked(System.String)">
            <summary>
            Returns true if the given key *might* be locked.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.AsyncLockProvider.TryExecuteAsync(System.String,System.Int32,ImageResizer.Plugins.DiskCache.AsyncLockCallback)">
            <summary>
            Attempts to execute the 'success' callback inside a lock based on 'key'.  If successful, returns true.
            If the lock cannot be acquired within 'timoutMs', returns false
            In a worst-case scenario, it could take up to twice as long as 'timeoutMs' to return false.
            </summary>
            <param name="key"></param>
            <param name="success"></param>
            <param name="timeoutMs"></param>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.UrlHasher.hash(System.String,System.Int32,System.String)">
            <summary>
            Builds a key for the cached version, using the hashcode of the normalized URL.
            if subfolders > 1, dirSeparator will be used to separate the subfolder and the key. 
            No extension is appended.
            I.e, a13514\124211ab132592 or 12412ababc12141
            </summary>
            <param name="data"></param>
            <param name="subfolders"></param>
            <param name="dirSeparator"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.UrlHasher.getSubfolder(System.Byte[],System.Int32)">
            <summary>
            Returns a string for the subfolder name. The bits used are from the end of the hash - this should make
            the hashes in each directory more unique, and speed up performance (8.3 filename calculations are slow when lots of files share the same first 6 chars.
            Returns null if not configured. Rounds subfolders up to the nearest power of two.
            </summary>
            <param name="hash"></param>
            <param name="subfolders"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.DiskCache.WebConfigWriter">
            <summary>
            Handles writing a Web.Config to disk that uses Url Authorization to prevent visitors 
            from accessing the files directly. Alternative Web.config content can be specified, this is a general-purpose implementation. Uses UTF-8 encoding.
            Also provides methods for efficient verification that the file still exists.
            Thread-safe.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.DiskCache.WebConfigWriter.webConfigContents">
            <summary>
            This string contains the contents of a web.conig file that sets URL authorization to "deny all" inside the current directory.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.WebConfigWriter.CheckWebConfigEvery5">
            <summary>
            Verifies a Web.config file is present in the directory every 5 minutes that the function is called, including the first time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.WebConfigWriter.CheckWebConfigOnce">
            <summary>
            If CheckWebConfig has never executed, it is executed immediately, but only once. 
            Verifies a Web.config file is present in the directory, and creates it if needed.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.WebConfigWriter.CheckWebConfig">
            <summary>
            Verifies a Web.config file is present in the directory, and creates it if needed.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.DiskCache.WebConfigWriter._checkWebConfig">
            <summary>
            Should only be called inside a lock. Creates the cache dir and the web.config file if they are missing. Updates
            _lastCheckedWebConfig and _checkedWebConfigOnce
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.MemCache.MemCachePlugin.LicenseFeatureCodes">
            <summary>
            Returns the license key feature codes that are able to activate this plugins.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.MemCache.MemCachePlugin.#ctor">
            <summary>
            Defaults to 10MB limit, and samples usage over the last 10 minutes when deciding what to remove. Stuff not used in the last 10 minutes gets discarded even if the limit hasn't been reached.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.MemCache.MemCachePlugin.Install(ImageResizer.Configuration.Config)">
            <summary>
            Adds the plugin to the given configuration container
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.MemCache.MemCachePlugin.Uninstall(ImageResizer.Configuration.Config)">
            <summary>
            Removes the plugin from the given configuration container
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.MemCache.MemCacheHandler">
            <summary>
            Implements IHttpHandler, serves content for the NoCache plugin
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin">
            <summary>
            Like DiskCache, but for source files. Not advisable if your source image collection is larger than available local storage.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.#ctor">
            <summary>
            Creates a new instance of SourceDiskCache
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.VirtualCacheDir">
            <summary>
            Sets the location of the cache directory. 
            Can be a virtual path (like /App/imagecache) or an application-relative path (like ~/imagecache, the default).
            Relative paths are assummed to be relative to the application root.
            All values are converted to virtual path format upon assignment (/App/imagecache)
            Will throw an InvalidOperationException if changed after the plugin is installed.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.PhysicalCacheDir">
            <summary>
            Returns the physical path of the cache directory specified in VirtualCacheDir.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.BeforeSettingChanged">
            <summary>
            Throws an exception if the class is already modified
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.Started">
            <summary>
            Returns true if the DiskCache instance is operational.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.Install(ImageResizer.Configuration.Config)">
            <summary>
            Loads the settings from 'c', starts the cache, and registers the plugin.
            Will throw an invalidoperationexception if already started.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.Uninstall(ImageResizer.Configuration.Config)">
            <summary>
            Removes this plugin from the given configuration container
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.IsConfigurationValid">
            <summary>
            Returns true if the configured settings are valid and .NET (not NTFS) permissions will work.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.HasFileIOPermission">
            <summary>
            Returns true if .NET permissions allow writing to the cache directory. Does not check NTFS permissions. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.Start">
            <summary>
            Attempts to start the DiskCache using the current settings. Returns true if succesful or if already started. Returns false on a configuration error.
            Called by Install()
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.Stop">
            <summary>
            Returns true if stopped succesfully. Cannot be restarted
            </summary>
            <returns></returns>
        </member>
        <member name="P:ImageResizer.Plugins.SourceDiskCache.SourceDiskCachePlugin.LicenseFeatureCodes">
            <summary>
            Returns the license key feature codes that are able to activate this plugins.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.ConstrainedCache`2.ReportedBytesUsed">
            <summary>
            The estimated ram usage for the entire cache. Relies upon the accuracy of the calculator delegate
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy">
            <summary>
            Specifies counter granularity, memory limits, cleanup intervals, and threading optimization level.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy.ThreadingPrecision.Fast">
            <summary>
            Much faster than accurate mode, but at the expense of extremely rare counter inaccuracies. Irrelevant in light of counter granularity, usually. 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy.Threading">
            <summary>
            Whether to optimize for performance or counter accuracy. Defaults to Fast
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy.CounterGranularity">
            <summary>
            How granular to track the time. For example, with a granularity of 8 (default), and an 8-minute tracking duration, the counter will track the last 7-8 minutes (maximum 0-59.9 second time window variance). 
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy.MaxBytesUsed">
            <summary>
            Specifies a hard limit on the number of bytes used for tracking purposes. Causes the smallest-valued items to get discarded first. Doesn't count key size unless SetCustomSize is called on the items. Set to 0 to disable (default)
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy.MinimumCleanupInterval">
            <summary>
            Specifies how often to eliminate 0-valued items from the dictionary. Defaults to 20 seconds. Only potentially triggered by .Increment() or PingCleanup() calls.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingStrategy.EstimatedCounterSize">
            <summary>
            The estimated size (in bytes) of a counter (excluding the key). Based on CounterGranularity
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1">
            <summary>
            Maintains a dictionary of keys to counters. Counters track how many events have occured during the last X minutes/seconds/ticks for the given item.
            Can enforce size limits and cleanup empty counters on an inverval.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.TrackingDuration">
            <summary>
            The duration for which to track events. For example, 5 minutes will keep a rolling value of how many events have occured in the last 5 minutes
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.ReportedBytesUsed">
            <summary>
            The estimated number of bytes used for tracking, plus the sum of the CustomSize values. Key space not included unless the caller always includes key size in CustomSize parameter.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.keysToCounters">
            <summary>
            For incrementing and finding counters based on keys
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.countersToKeys">
            <summary>
            Purely for cleanup purposes. Allows fast removal of pairs based on the EventCounter instance.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.syncLock">
            <summary>
            Lock for access to dictionaries
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.sortLock">
            <summary>
            Lock on EventCounter.sortValue members. Redundant with cleanupLock implemented.
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.cleanupLock">
            <summary>
            Lock to prevent concurrent cleanups from occuring
            </summary>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.timerLock">
            <summary>
            Lock to prevent duplicate work items from being scheduled.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.PingCleanup">
            <summary>
            Starts cleanup on a thread pool thread if it hasn't been started within the desired interval. If cleanup starts and other cleanup is running, it cancels. The assumption is that one cleanup of either type is enough within the interval.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.Cleanup(ImageResizer.Plugins.SourceMemCache.EventCountingDictionary{`0}.CleanupMode)">
            <summary>
            Performs cleanup on the dictionaries in either MakeRoom or Maintenance mode. Returns true if the goal was achieved, false if the cleanup was canceled because another cleanup was executing conurrently.
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.Increment(`0,System.Int64)">
            <summary>
            Increment the counter for the given item. Pings cleanup as well.
            </summary>
            <param name="key"></param>
            <param name="customSize"> Sets the custom size offset for the specified key (used for cleanup purposes). If -1, existing value will remain unchanged. </param>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.EventCountingDictionary`1.GetValue(`0)">
            <summary>
            Calculate the counter value for the given item
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:ImageResizer.Plugins.SourceMemCache.EventCounter">
            <summary>
            Maintains a rotating data structure to track events over a moving time period.
            </summary>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.EventCounter.CustomSize">
            <summary>
            User-defined size of related item (key and/or a related cache object). Defaults to 0;
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.EventCounter.GetValue">
            <summary>
            Returns the value of the counter
            </summary>
            <returns></returns>
        </member>
        <member name="F:ImageResizer.Plugins.SourceMemCache.EventCounter.sortValue">
            <summary>
            Warning! Not synchronized or updated. Use must be externally synchromized and value set externally
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.SourceMemCachePlugin.#ctor">
            <summary>
            Defaults to 10MB limit, and samples usage over the last 10 minutes when deciding what to remove. Stuff not used in the last 10 minutes gets discarded even if the limit hasn't been reached.
            </summary>
        </member>
        <member name="M:ImageResizer.Plugins.SourceMemCache.SourceMemCachePlugin.GetFileIfCached(System.String,System.Collections.Specialized.NameValueCollection,ImageResizer.Plugins.IVirtualFile)">
            <summary>
            Retrieves file if cached.
            </summary>
            <param name="virtualPath"></param>
            <param name="queryString"></param>
            <param name="original"></param>
            <returns></returns>
        </member>
        <member name="P:ImageResizer.Plugins.SourceMemCache.SourceMemCachePlugin.LicenseFeatureCodes">
            <summary>
            Returns the license key feature codes that are able to activate this plugins.
            </summary>
        </member>
        <member name="T:ImageResizer.Plugins.SourceMemCache.CachedVirtualFile">
            <summary>
            Source file cached in memory.
            </summary>
        </member>
    </members>
</doc>
